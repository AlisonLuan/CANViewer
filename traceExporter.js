// traceExporter.js

/**
 * @module traceExporter
 * Utilities for exporting CAN-log entries in CSV, TRC, and ASC formats.
 */

/**
 * @typedef {Object} LogEntry
 * @property {string} timestamp  – ISO-style timestamp or any timestamp string
 * @property {string} id         – CAN ID (hex string)
 * @property {string} type       – Message type (e.g. 'STD', 'EXT', 'TX', 'RX', 'SYS')
 * @property {number} dlc        – Data length code
 * @property {string} data       – Space-separated hex bytes
 * @property {number} [offset]   – Time offset in seconds (used by TRC/ASC)
 */

/**
 * Generate a CSV export from an array of log entries.
 * @param {LogEntry[]} logEntries
 * @returns {string} CSV formatted (comma-separated, quoted) content
 * @throws {TypeError} If logEntries is not an array
 */
export const generateCsv = (logEntries) => {
    if (!Array.isArray(logEntries)) {
      throw new TypeError('generateCsv: logEntries must be an array');
    }
  
    const header = ['Timestamp', 'ID', 'Type', 'DLC', 'Data'];
    const rows = logEntries.map(({ timestamp, id, type, dlc, data }) => [
      timestamp,
      id,
      type,
      dlc,
      data,
    ]);
  
    // Quote every field, join with commas, then join rows with LF
    const lines = [header, ...rows]
      .map((fields) => fields.map((v) => `"${v}"`).join(','));
  
    return lines.join('\n');
  };
  
  /**
   * Generate a Peak TRC export from log entries.
   * @param {LogEntry[]} logEntries
   * @param {number} startTimeMs — reference start time in ms since UNIX epoch
   * @returns {string} TRC formatted content
   * @throws {TypeError} If inputs are invalid
   */
  export const generateTrc = (logEntries, startTimeMs) => {
    if (!Array.isArray(logEntries)) {
      throw new TypeError('generateTrc: logEntries must be an array');
    }
    if (typeof startTimeMs !== 'number') {
      throw new TypeError('generateTrc: startTimeMs must be a number');
    }
  
    const lines = [
      ';$FILEVERSION=2.1',
      // Excel serial date: days since 1900-01-00
      `;$STARTTIME=${Date.now() / 86400000 + 25569}`,
      ';$COLUMNS=N,O,T,B,I,d,R,L,D',
      ';',
      `;   ${window.location.pathname}`,
      ';',
      `;   Start time: ${new Date(startTimeMs).toISOString()}`,
      ';   Generated by WebUSB CAN Logger',
      ';-------------------------------------------------------------------------------',
      ';   Bus   Name            Connection               Protocol',
      ';   N/A   N/A             N/A                      N/A',
      ';-------------------------------------------------------------------------------',
      ';   Message   Time    Type    ID     Rx/Tx',
      ';   Number    Offset  |  Bus  [hex]  |  Reserved',
      ';   |         [ms]    |  |    |      |  |  Data Length Code',
      ';   |         |       |  |    |      |  |  |    Data [hex] ...',
      ';   |         |       |  |    |      |  |  |    |',
      ';---+-- ------+------ +- +- --+----- +- +- +--- +- -- -- -- -- -- -- --',
    ];
  
    logEntries.forEach(({ offset = 0, id, type, dlc, data }, index) => {
      const msgNum      = index.toString().padStart(6, ' ');
      const msOffset    = (offset * 1000).toFixed(3).padStart(9, ' ');
      const direction   = type === 'TX' ? 'Tx -' : 'Rx -';
      const lengthField = String(dlc).padStart(2, ' ');
      // DT=Data Transfer, Bus=1 (hardcoded), then ID, direction, length, data
      lines.push(
        `${msgNum} ${msOffset} DT  1 ${id} ${direction} ${lengthField}    ${data}`
      );
    });
  
    return lines.join('\r\n');
  };
  
  /**
   * Generate an ASC export from log entries.
   * @param {LogEntry[]} logEntries
   * @param {number} startTimeMs — reference start time in ms since UNIX epoch
   * @returns {string} ASC formatted content
   * @throws {TypeError} If inputs are invalid
   */
  export const generateAsc = (logEntries, startTimeMs) => {
    if (!Array.isArray(logEntries)) {
      throw new TypeError('generateAsc: logEntries must be an array');
    }
    if (typeof startTimeMs !== 'number') {
      throw new TypeError('generateAsc: startTimeMs must be a number');
    }
  
    const now = new Date().toString();
    const start = new Date(startTimeMs).toString();
    const lines = [
      `date ${now}`,
      'base hex timestamps absolute',
      'internal events logged',
      `Begin Triggerblock ${start}`,
    ];
  
    logEntries.forEach(({ offset = 0, id, type, dlc, data }) => {
      const timeOffset = offset.toFixed(6);
      const direction  = type === 'TX' ? 'Tx' : 'Rx';
      // Note the trailing 'x' after ID is part of the ASC format
      lines.push(
        ` ${timeOffset} 1  ${id}x       ${direction}   d ${dlc} ${data}`
      );
    });
  
    return lines.join('\r\n');
  };  